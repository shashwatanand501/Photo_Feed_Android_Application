{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}import invariant from\"../utils/invariant\";import shallowEqual from\"../utils/shallowEqual\";var SCENE_KEY_PREFIX='scene_';function compareKey(one,two){var delta=one.length-two.length;if(delta>0){return 1;}if(delta<0){return-1;}return one>two?1:-1;}function compareScenes(one,two){if(one.index>two.index){return 1;}if(one.index<two.index){return-1;}return compareKey(one.key,two.key);}function areScenesShallowEqual(one,two){return one.key===two.key&&one.index===two.index&&one.isStale===two.isStale&&one.isActive===two.isActive&&areRoutesShallowEqual(one.route,two.route);}function areRoutesShallowEqual(one,two){if(!one||!two){return one===two;}if(one.key!==two.key){return false;}return shallowEqual(one,two);}export default function ScenesReducer(scenes,nextState,prevState,descriptors){scenes.forEach(function(scene){var route=scene.route;if(descriptors&&descriptors[route.key]){scene.descriptor=descriptors[route.key];}});if(prevState===nextState){return scenes;}var prevScenes=new Map();var freshScenes=new Map();var staleScenes=new Map();scenes.forEach(function(scene){var key=scene.key;if(scene.isStale){staleScenes.set(key,scene);}prevScenes.set(key,scene);});var nextKeys=new Set();nextState.routes.forEach(function(route,index){var key=SCENE_KEY_PREFIX+route.key;var descriptor=descriptors&&descriptors[route.key];var scene={index:index,isActive:false,isStale:false,key:key,route:route,descriptor:descriptor};invariant(!nextKeys.has(key),\"navigation.state.routes[\"+index+\"].key \\\"\"+key+\"\\\" conflicts with \"+'another route!');nextKeys.add(key);if(staleScenes.has(key)){staleScenes.delete(key);}freshScenes.set(key,scene);});if(prevState){prevState.routes.forEach(function(route,index){var key=SCENE_KEY_PREFIX+route.key;if(freshScenes.has(key)){return;}var lastScene=scenes.find(function(scene){return scene.route.key===route.key;});var descriptor=lastScene?lastScene.descriptor:descriptors[route.key];if(descriptor){staleScenes.set(key,{index:index,isActive:false,isStale:true,key:key,route:route,descriptor:descriptor});}});}var nextScenes=[];var mergeScene=function mergeScene(nextScene){var key=nextScene.key;var prevScene=prevScenes.has(key)?prevScenes.get(key):null;if(prevScene&&areScenesShallowEqual(prevScene,nextScene)){nextScenes.push(prevScene);}else{nextScenes.push(nextScene);}};staleScenes.forEach(mergeScene);freshScenes.forEach(mergeScene);nextScenes.sort(compareScenes);var activeScenesCount=0;nextScenes.forEach(function(scene,ii){var isActive=!scene.isStale&&scene.index===nextState.index;if(isActive!==scene.isActive){nextScenes[ii]=_objectSpread(_objectSpread({},scene),{},{isActive:isActive});}if(isActive){activeScenesCount++;}});invariant(activeScenesCount===1,'there should always be only one scene active, not %s.',activeScenesCount);if(nextScenes.length!==scenes.length){return nextScenes;}if(nextScenes.some(function(scene,index){return!areScenesShallowEqual(scenes[index],scene);})){return nextScenes;}return scenes;}","map":{"version":3,"sources":["E:/photofeed/node_modules/react-navigation-stack/dist/views/ScenesReducer.js"],"names":["invariant","shallowEqual","SCENE_KEY_PREFIX","compareKey","one","two","delta","length","compareScenes","index","key","areScenesShallowEqual","isStale","isActive","areRoutesShallowEqual","route","ScenesReducer","scenes","nextState","prevState","descriptors","forEach","scene","descriptor","prevScenes","Map","freshScenes","staleScenes","set","nextKeys","Set","routes","has","add","delete","lastScene","find","nextScenes","mergeScene","nextScene","prevScene","get","push","sort","activeScenesCount","ii","some"],"mappings":"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","sourcesContent":["import invariant from '../utils/invariant';\nimport shallowEqual from '../utils/shallowEqual';\n\nconst SCENE_KEY_PREFIX = 'scene_';\n\n/**\n * Helper function to compare route keys (e.g. \"9\", \"11\").\n */\nfunction compareKey(one, two) {\n  const delta = one.length - two.length;\n  if (delta > 0) {\n    return 1;\n  }\n  if (delta < 0) {\n    return -1;\n  }\n  return one > two ? 1 : -1;\n}\n\n/**\n * Helper function to sort scenes based on their index and view key.\n */\nfunction compareScenes(one, two) {\n  if (one.index > two.index) {\n    return 1;\n  }\n  if (one.index < two.index) {\n    return -1;\n  }\n\n  return compareKey(one.key, two.key);\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areScenesShallowEqual(one, two) {\n  return one.key === two.key && one.index === two.index && one.isStale === two.isStale && one.isActive === two.isActive && areRoutesShallowEqual(one.route, two.route);\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areRoutesShallowEqual(one, two) {\n  if (!one || !two) {\n    return one === two;\n  }\n\n  if (one.key !== two.key) {\n    return false;\n  }\n\n  return shallowEqual(one, two);\n}\n\nexport default function ScenesReducer(scenes, nextState, prevState, descriptors) {\n  // Always update the descriptors\n  // This is a workaround for https://github.com/react-navigation/react-navigation/issues/4271\n  // It will be resolved in a better way when we re-write Transitioner\n  scenes.forEach(scene => {\n    const { route } = scene;\n    if (descriptors && descriptors[route.key]) {\n      scene.descriptor = descriptors[route.key];\n    }\n  });\n\n  // Bail out early if we didn't update the state\n  if (prevState === nextState) {\n    return scenes;\n  }\n\n  const prevScenes = new Map();\n  const freshScenes = new Map();\n  const staleScenes = new Map();\n\n  // Populate stale scenes from previous scenes marked as stale.\n  scenes.forEach(scene => {\n    const { key } = scene;\n    if (scene.isStale) {\n      staleScenes.set(key, scene);\n    }\n    prevScenes.set(key, scene);\n  });\n\n  const nextKeys = new Set();\n  nextState.routes.forEach((route, index) => {\n    const key = SCENE_KEY_PREFIX + route.key;\n\n    let descriptor = descriptors && descriptors[route.key];\n\n    const scene = {\n      index,\n      isActive: false,\n      isStale: false,\n      key,\n      route,\n      descriptor\n    };\n    invariant(!nextKeys.has(key), `navigation.state.routes[${index}].key \"${key}\" conflicts with ` + 'another route!');\n    nextKeys.add(key);\n\n    if (staleScenes.has(key)) {\n      // A previously `stale` scene is now part of the nextState, so we\n      // revive it by removing it from the stale scene map.\n      staleScenes.delete(key);\n    }\n    freshScenes.set(key, scene);\n  });\n\n  if (prevState) {\n    // Look at the previous routes and classify any removed scenes as `stale`.\n    prevState.routes.forEach((route, index) => {\n      const key = SCENE_KEY_PREFIX + route.key;\n      if (freshScenes.has(key)) {\n        return;\n      }\n      const lastScene = scenes.find(scene => scene.route.key === route.key);\n\n      // We can get into a weird place where we have a queued transition and then clobber\n      // that transition without ever actually rendering the scene, in which case\n      // there is no lastScene. If the descriptor is not available on the lastScene\n      // or the descriptors prop then we just skip adding it to stale scenes and it's\n      // not ever rendered.\n      const descriptor = lastScene ? lastScene.descriptor : descriptors[route.key];\n\n      if (descriptor) {\n        staleScenes.set(key, {\n          index,\n          isActive: false,\n          isStale: true,\n          key,\n          route,\n          descriptor\n        });\n      }\n    });\n  }\n\n  const nextScenes = [];\n\n  const mergeScene = nextScene => {\n    const { key } = nextScene;\n    const prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;\n    if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {\n      // Reuse `prevScene` as `scene` so view can avoid unnecessary re-render.\n      // This assumes that the scene's navigation state is immutable.\n      nextScenes.push(prevScene);\n    } else {\n      nextScenes.push(nextScene);\n    }\n  };\n\n  staleScenes.forEach(mergeScene);\n  freshScenes.forEach(mergeScene);\n\n  nextScenes.sort(compareScenes);\n\n  let activeScenesCount = 0;\n  nextScenes.forEach((scene, ii) => {\n    const isActive = !scene.isStale && scene.index === nextState.index;\n    if (isActive !== scene.isActive) {\n      nextScenes[ii] = {\n        ...scene,\n        isActive\n      };\n    }\n    if (isActive) {\n      activeScenesCount++;\n    }\n  });\n\n  invariant(activeScenesCount === 1, 'there should always be only one scene active, not %s.', activeScenesCount);\n\n  if (nextScenes.length !== scenes.length) {\n    return nextScenes;\n  }\n\n  if (nextScenes.some((scene, index) => !areScenesShallowEqual(scenes[index], scene))) {\n    return nextScenes;\n  }\n\n  // scenes haven't changed.\n  return scenes;\n}"]},"metadata":{},"sourceType":"module"}